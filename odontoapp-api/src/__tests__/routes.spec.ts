import {
  describe,
  beforeEach,
  afterEach,
  it,
  expect,
  beforeAll,
  afterAll,
} from 'vitest';
import request from 'supertest';
import express from 'express';
import Server from '@/server';
import { Server as HTTPServer } from 'http';
import bcrypt from 'bcrypt';
import config from '@/etc/config';
import prisma from '@/db';
import { Users } from '@prisma/client';

const app = express();
const server = new Server({ app, port: 4444 });
let myAppInstance: HTTPServer | null = null;
let testDBUser: Users;
let testDBAdmin: Users;
let testDBDentist: Users;
let testDBLab: Users;

type AuthUserResponse = { user: Users; token: string };

let authenticatedUser: AuthUserResponse;
let authenticatedAdmin: AuthUserResponse;
let authenticatedDentist: AuthUserResponse;
let authenticatedLab: AuthUserResponse;

describe('/users', () => {
  const acceptableUserData = {
    name: 'John Doe',
    email: 'john.doe@email.com',
    // generated by http://www.jmssolucoes.com.br/gerador-de-cpf-cnpj.aspx
    cpf: '13368116177',
    password: '123123',
    confirm_password: '123123',
    account_type: 1,
  };

  const acceptableDentistData = {
    name: 'Dentist Doe',
    email: 'dentist.doe@email.com',
    // generated by https://geradornv.com.br/gerador-cpf/
    cpf: '13054786498',
    password: '123123',
    confirm_password: '123123',
    account_type: 1,
  };

  const acceptableLabData = {
    name: 'Lab Doe',
    email: 'lab.doe@email.com',
    // generated by https://geradornv.com.br/gerador-cpf/
    cpf: '58765144465',
    password: '123123',
    confirm_password: '123123',
    account_type: 2,
  };

  const acceptablePatientData = {
    patient_name: 'Patricia Doe',
    patient_email: 'patricia.doe@email.com',
    patient_address: 'Patricia Doe Avenue, 123',
    // generated by https://geradornv.com.br/gerador-cep/
    patient_zip: '17212-200',
    patient_cellphone: '41989891212',
    // generated by https://geradornv.com.br/gerador-cpf/

    patient_cpf: '81172524815',
    patient_birth: new Date('03/06/1992').toISOString(),
    patient_sex: 'F',
  };

  beforeAll(async () => {
    const [
      encriptedUserPassword,
      encriptedDentistPassword,
      encriptedLabPassword,
    ] = await Promise.all([
      bcrypt.hash(acceptableUserData.password, config.hash.salt),
      bcrypt.hash(acceptableUserData.password, config.hash.salt),
      bcrypt.hash(acceptableUserData.password, config.hash.salt),
    ]);

    const [dbUser, dbAdmin, dbDentist, dbLab] = await Promise.all([
      prisma.users.create({
        data: {
          name: acceptableUserData.name,
          email: acceptableUserData.email,
          cpf: acceptableUserData.cpf,
          // password: '123123',
          password: encriptedUserPassword,
          role: 'DENTIST',
        },
      }),
      prisma.users.create({
        data: {
          name: 'Admin user',
          email: 'admin@email.com',
          password: encriptedUserPassword,
          role: 'ADMIN',
        },
      }),
      prisma.users.create({
        data: {
          name: acceptableDentistData.name,
          email: acceptableDentistData.email,
          // generated by https://geradornv.com.br/gerador-cpf/
          cpf: acceptableDentistData.cpf,
          // password: '123123',
          password: encriptedDentistPassword,
          role: 'DENTIST',
        },
      }),
      prisma.users.create({
        data: {
          name: acceptableLabData.name,
          email: acceptableLabData.email,
          // generated by https://geradornv.com.br/gerador-cpf/
          cpf: acceptableLabData.cpf,
          // password: '123123',
          password: encriptedLabPassword,
          role: 'LAB',
        },
      }),
    ]);

    testDBUser = dbUser;
    testDBAdmin = dbAdmin;
    testDBDentist = dbDentist;
    testDBLab = dbLab;
  });

  afterAll(async () => {
    await prisma.users.deleteMany({});
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    myAppInstance = await server.init();

    const [userPromise, adminPromise, dentistPromise, labPromise] =
      await Promise.all([
        request(myAppInstance).post('/session').send({
          email: testDBUser.email,
          password: acceptableUserData.password,
        }),

        request(myAppInstance).post('/session').send({
          email: testDBAdmin.email,
          password: acceptableUserData.password,
        }),

        request(myAppInstance).post('/session').send({
          email: testDBDentist.email,
          password: acceptableDentistData.password,
        }),

        request(myAppInstance).post('/session').send({
          email: testDBLab.email,
          password: acceptableLabData.password,
        }),
      ]);

    authenticatedAdmin = adminPromise.body.data;
    authenticatedUser = userPromise.body.data;
    authenticatedDentist = dentistPromise.body.data;
    authenticatedLab = labPromise.body.data;
  });

  afterEach(() => {
    server.close();
  });

  describe('/session :: POST', () => {
    it('should return 400 and error message when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: 'John Doe' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Email/Password required.',
      });
    });

    it('should return 400 and error message when invalid email is sent', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: 'John Doe', password: '123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid e-mail.',
      });
    });

    it('should return 400 and error message when email does not have associated user', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: 'jane@email.com', password: '123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Email/Password does not match.',
      });
    });

    it('should return 400 and error message when password is incorrect', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: testDBUser.email, password: 'invalid password' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Email/Password does not match.',
      });
    });

    it("should return 200 and 'ok' message when email and password are correct", async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: testDBUser.email, password: '123123' });

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data.user).sort()).toEqual(
        [
          'id',
          'email',
          'name',
          'cro',
          'cpf',
          'cellphone',
          'phone',
          'company',
          'address',
          'birth',
          'post',
          'colorScale',
          'role',
          'services',
        ].sort()
      );
      expect(response.body).toEqual({
        message: 'ok',
        data: {
          user: response.body.data.user,
          token: response.body.data.token,
        },
      });
    });
  });

  describe('/users :: POST', () => {
    it('should return 400, error message and invalid fields when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ name: '' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'All fields required.',
        fields: ['name'],
      });
    });

    it('should return 400, error message and invalid fields when password is different than confirm_password', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, confirm_password: '123456' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Password/Confirm password must match.',
        fields: ['password', 'confirm_password'],
      });
    });

    it('should return 400, error message and invalid fields when account_type is lower than 1 or higher than 2', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, account_type: 5 });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid account type.',
        fields: ['account_type'],
      });
    });

    it('should return 400, error message and invalid fields when cpf is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, cpf: '123123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CPF/CNPJ.',
        fields: ['cpf'],
      });
    });

    it('should return 400, error message and invalid fields when email is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, email: 'john.doe@' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid e-mail.',
        fields: ['email'],
      });
    });

    it('should return 400, error message and invalid fields when CPF/CPNJ is already used', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, cpf: testDBUser.cpf });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'CPF/CNPJ already used.',
        fields: ['cpf'],
      });
    });

    it('should return 400, error message and invalid fields when email is already used', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({
          ...acceptableUserData,
          // generated by http://www.jmssolucoes.com.br/gerador-de-cpf-cnpj.aspx
          cpf: '185.339.850-02',
          email: testDBUser.email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'E-mail already used.',
        fields: ['email'],
      });
    });

    it("should return 201 and 'ok' mesasge when all input data is correct", async () => {
      const response = await request(myAppInstance).post('/users').send({
        name: 'Jane Doe',
        email: 'jane.doe@email.com',
        // generated by http://www.jmssolucoes.com.br/gerador-de-cpf-cnpj.aspx
        cpf: '185.339.850-02',
        password: '123123',
        confirm_password: '123123',
        account_type: 1,
      });

      expect(response.statusCode).toEqual(201);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'uid',
          'name',
          'email',
          'birth',
          'active',
          'address',
          'company',
          'cpf',
          'cro',
          'phone',
          'cellphone',
          'post',
        ].sort()
      );
      expect(response.body.message).toEqual('ok');
    });
  });

  describe('/users :: PUT', () => {
    it('should return 400 and error message when user_password and confirm_user_password does not match', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({ user_password: '123123', user_confirm_password: '123456' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Password/Confirm password must match.',
        fields: ['user_password', 'user_confirm_password'],
      });
    });

    it('should return 400 and error message when user_email and user_confirm_email does not match', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_email: 'new-email@email.com',
          user_confirm_email: 'different-email@email.com',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'E-mail/Confirm e-mail must match.',
        fields: ['user_email', 'user_confirm_email'],
      });
    });

    it('should return 400 and error message when user_email is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_email: 'new-email@email',
          user_confirm_email: 'new-email@email',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid user e-mail.',
        fields: ['user_email'],
      });
    });

    it('should return 400 and error message when user_email is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_email: alreadyRegisteredUser.email,
          user_confirm_email: alreadyRegisteredUser.email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'User e-mail already used.',
        fields: ['user_email'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return 400 and error message when user_cpf is invalid', async () => {
      const {
        body: {
          data: { token },
        },
      } = await request(myAppInstance)
        .post('/session')
        .send({ email: testDBAdmin.email, password: '123123' });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${token}`)
        .send({
          user_cpf: 'invalid-cpf',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CPF.',
        fields: ['user_cpf'],
      });
    });

    it('should return 400 and error message when company_primary_email is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_primary_email: 'invalid-email@email',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid primary e-mail.',
        fields: ['company_primary_email'],
      });
    });

    it('should return 400 and error message when company_primary_email is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const alreadyRegisteredCompanyData = {
        primary_email: 'already-used@email.com',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
          company: {
            create: {
              primary_email: alreadyRegisteredCompanyData.primary_email,
            },
          },
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_primary_email: alreadyRegisteredCompanyData.primary_email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Primary e-mail already used.',
        fields: ['company_primary_email'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return 400 and error message when company_secondary_email is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_secondary_email: 'invalid-email@email',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid secondary e-mail.',
        fields: ['company_secondary_email'],
      });
    });

    it('should return 400 and error message when company_secondary_email is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const alreadyRegisteredCompanyData = {
        secondary_email: 'already-used@email.com',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
          company: {
            create: {
              secondary_email: alreadyRegisteredCompanyData.secondary_email,
            },
          },
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_secondary_email: alreadyRegisteredCompanyData.secondary_email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Secondary e-mail already used.',
        fields: ['company_secondary_email'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return 400 and error message when user_cnpj is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_cnpj: 'invalid-cnpj',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CNPJ.',
        fields: ['company_cnpj'],
      });
    });

    it('should return 400 and error message when company_cnpj is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const alreadyRegisteredCompanyData = {
        // generated by http://www.jmssolucoes.com.br/gerador-de-cpf-cnpj.aspx
        cnpj: '93110632000199',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
          company: {
            create: {
              cnpj: alreadyRegisteredCompanyData.cnpj,
            },
          },
        },
        include: {
          company: true,
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_cnpj: '93110632000199',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'CNPJ already used.',
        fields: ['company_cnpj'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return 400 and error message when company_phone is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_phone: 'invalid-phone',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid Phone.',
        fields: ['company_phone'],
      });
    });

    it('should return 400 and error message when company_cellphone is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_cellphone: 'invalid-cellphone',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid Cellphone.',
        fields: ['company_cellphone'],
      });
    });

    it('should return 200 and ok message when all input data is correct', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_name: 'Test User',
          user_birth: '1992-03-06T00:00:00.000Z',
          user_address: 'John Doe Avenue 890',
          user_email: 'john.doe.test@email.com',
          user_confirm_email: 'john.doe.test@email.com',
          user_post: 'Dentist',
          user_password: '123123',
          user_confirm_password: '123123',
          company_name: 'John Doe Company',
          company_primary_email: 'john.doe.test.primary@john-doe-company.com',
          company_secondary_email:
            'john.doe.test.secondary@john-doe-company.com',
          company_cellphone: '11999112211',
          company_phone: '1131313232',
          company_cnpj: '58349746000195',
          company_webiste: 'https://john-doe-company.com',
          company_address: 'John Doe Company Avenue, 1337',
        });

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'uid',
          'name',
          'email',
          'birth',
          'address',
          'company',
          'cpf',
          'cro',
          'phone',
          'cellphone',
          'post',
        ].sort()
      );
      expect(Object.keys(response.body.data.company).sort()).toEqual(
        [
          'address',
          'primary_email',
          'secondary_email',
          'cellphone',
          'cnpj',
          'name',
          'phone',
          'website',
        ].sort()
      );
      expect(response.body.message).toEqual('ok');
    });
  });

  describe('/users :: DELETE', () => {
    it('should return status 200 and ok message when correct id is sent', async () => {
      const deletedUserData = {
        name: 'Johnny Doe',
        email: 'johnny.doe@email.com',
        // generated by https://www.4devs.com.br/gerador_de_cpf
        cpf: '22210958040',
        password: '123123',
      };

      const encriptedPassword = await bcrypt.hash(
        deletedUserData.password,
        config.hash.salt
      );

      const deletedUser = await prisma.users.create({
        data: {
          ...deletedUserData,
          password: encriptedPassword,
          company: {
            create: {},
          },
        },
      });

      const response = await request(myAppInstance)
        .delete(`/users/${deletedUser.uid}`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'ok',
      });

      await prisma.users.delete({
        where: {
          uid: deletedUser.uid,
        },
      });
    });
  });

  describe('/users :: GET', () => {
    it('should return status 200 and a list of users', async () => {
      const response = await request(myAppInstance)
        .get(`/users`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toBe('ok');
      expect(Array.isArray(response.body.data)).toBe(true);
    });
  });

  describe('/users/:id :: GET', () => {
    it('should return status 403 and error message when invalid id is sent', async () => {
      const response = await request(myAppInstance)
        .get(`/users/invalid-id`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(403);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid id.',
      });
    });

    it('should return status 400 and error message when user is not found', async () => {
      const response = await request(myAppInstance)
        .get(`/users/84fd6184-7ca2-4a90-be6b-a0341f1b3b3c`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'User not found',
      });
    });

    it('should return status 200 and user data when correct id is sent', async () => {
      const response = await request(myAppInstance)
        .get(`/users/${testDBUser.uid}`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toBe('ok');
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'uid',
          'name',
          'email',
          'active',
          'address',
          'company',
          'cpf',
          'cro',
          'phone',
          'cellphone',
          'birth',
          'post',
        ].sort()
      );
      expect(Object.keys(response.body.data.company).sort()).toEqual(
        [
          'uid',
          'primary_email',
          'secondary_email',
          'name',
          'cnpj',
          'cellphone',
          'phone',
          'address',
          'website',
          'active',
        ].sort()
      );
    });
  });

  describe('/patients :: POST', () => {
    it('should return 400, error message and invalid fields when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ patient_name: '' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'All fields required.',
        fields: ['patient_name'],
      });
    });

    it('should return 400, error message and invalid fields when cpf is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData, patient_cpf: '123123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CPF.',
        fields: ['patient_cpf'],
      });
    });

    it('should return status 400, error message and invalid fields when patient cpf is already used', async () => {
      const registeredPatient = await prisma.users.update({
        where: {
          uid: testDBDentist.uid,
        },
        data: {
          patients: {
            connectOrCreate: {
              create: {
                cpf: acceptablePatientData.patient_cpf,
                name: acceptablePatientData.patient_name,
                role: 'PATIENT',
                address: acceptablePatientData.patient_address,
                birth: acceptablePatientData.patient_birth,
                cellphone: acceptablePatientData.patient_cellphone,
                email: acceptablePatientData.patient_email,
                sex: false,
                zip_code: acceptablePatientData.patient_zip,
              },
              where: {
                cpf: acceptablePatientData.patient_cpf,
              },
            },
          },
        },
        select: {
          patients: {
            where: {
              cpf: acceptablePatientData.patient_cpf,
            },
          },
        },
      });

      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'You already have a patient with this CPF',
        fields: ['patient_cpf'],
      });

      await prisma.patients.delete({
        where: {
          uid: registeredPatient.patients[0].uid,
        },
      });
    });

    it('should return 400, error message and invalid fields when email is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData, patient_email: 'invalid-email' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid e-mail.',
        fields: ['patient_email'],
      });
    });

    it('should return 400, error message and invalid fields when sex is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData, patient_sex: 'invalid-sex' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid sex.',
        fields: ['patient_sex'],
      });
    });

    it('should return 400, error message and invalid fields when date is invalid or is after today', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
          patient_birth: new Date('01/01/2099').toISOString(),
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid birth date.',
        fields: ['patient_birth'],
      });
    });

    it('should return 400, error message and invalid fields when cellphone is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
          patient_cellphone: 'invalid-cellphone',
        });

      console.log({ acceptablePatientData });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid cellphone/phone.',
        fields: ['patient_cellphone'],
      });
    });

    it('should return 400, error message and invalid fields when zipcode is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
          patient_zip: 'invalid-zip',
        });

      console.log({ acceptablePatientData });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid zipcode.',
        fields: ['patient_zip'],
      });
    });
  });
});
