import {
  describe,
  beforeEach,
  afterEach,
  it,
  expect,
  beforeAll,
  afterAll,
} from 'vitest';
import request from 'supertest';
import express from 'express';
import Server from '@/server';
import { Server as HTTPServer } from 'http';
import bcrypt from 'bcrypt';
import config from '@/etc/config';
import prisma from '@/db';
import { Users } from '@prisma/client';
import { addDays } from 'date-fns';

type AuthUserResponse = { user: Users; token: string };

const app = express();
const server = new Server({ app, port: 4444 });
let myAppInstance: HTTPServer | null = null;
let authenticatedUser: AuthUserResponse;
let authenticatedAdmin: AuthUserResponse;
let authenticatedDentist: AuthUserResponse;
let authenticatedLab: AuthUserResponse;

const acceptableUserData = {
  name: 'John Doe',
  email: 'john.doe@email.com',
  // generated by https://geradornv.com.br/gerador-cpf/
  cpf: '13368116177',
  password: '123123',
  confirm_password: '123123',
  account_type: 1,
};

const acceptableDentistData = {
  name: 'Dentist Doe',
  email: 'dentist.doe@email.com',
  // generated by https://geradornv.com.br/gerador-cpf/
  cpf: '13054786498',
  password: '123123',
  confirm_password: '123123',
  account_type: 1,
};

const acceptableLabData = {
  name: 'Lab Doe',
  email: 'lab.doe@email.com',
  // generated by https://geradornv.com.br/gerador-cpf/
  cpf: '58765144465',
  password: '123123',
  confirm_password: '123123',
  account_type: 2,
};

const acceptablePatientData = {
  patient_name: 'Patricia Doe',
  patient_email: 'patricia.doe@email.com',
  patient_address: 'Patricia Doe Avenue, 123',
  // generated by https://geradornv.com.br/gerador-cep/
  patient_zip: '17212-200',
  patient_cellphone: '41989891212',
  // generated by https://geradornv.com.br/gerador-cpf/
  patient_cpf: '81172524815',
  patient_birth: new Date('03/06/1992').toISOString(),
  patient_sex: 'F',
};

describe('/session', () => {
  let testDBUser: Users;

  beforeAll(async () => {
    const encryptedPassword = await bcrypt.hash(
      acceptableUserData.password,
      config.hash.salt
    );

    const [dbUser] = await Promise.all([
      prisma.users.create({
        data: {
          name: acceptableUserData.name,
          email: acceptableUserData.email,
          cpf: acceptableUserData.cpf,
          // password: '123123',
          password: encryptedPassword,
          role: 'DENTIST',
          company: {
            create: {},
          },
        },
      }),
      prisma.users.create({
        data: {
          name: 'Admin user',
          email: 'admin@email.com',
          password: encryptedPassword,
          role: 'ADMIN',
        },
      }),
    ]);

    testDBUser = dbUser;
  });

  afterAll(async () => {
    await prisma.users.deleteMany({});
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    myAppInstance = await server.init();
  });

  afterEach(() => {
    server.close();
  });

  describe('/session :: POST', () => {
    it('should return status 400 and error message when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: 'John Doe' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Email/Password required.',
      });
    });

    it('should return status 400 and error message when invalid email is sent', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: 'John Doe', password: '123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid e-mail.',
      });
    });

    it('should return status 400 and error message when email does not have associated user', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: 'jane@email.com', password: '123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Email/Password does not match.',
      });
    });

    it('should return status 400 and error message when password is incorrect', async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: testDBUser.email, password: 'invalid password' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Email/Password does not match.',
      });
    });

    it("should return 200 and 'ok' message when email and password are correct", async () => {
      const response = await request(myAppInstance)
        .post('/session')
        .send({ email: testDBUser.email, password: '123123' });

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data.user).sort()).toEqual(
        [
          'id',
          'email',
          'name',
          'cro',
          'cpf',
          'cellphone',
          'phone',
          'company',
          'address',
          'birth',
          'post',
          'colorScale',
          'role',
          'services',
          'menu',
        ].sort()
      );
      expect(response.body).toEqual({
        message: 'ok',
        data: {
          user: response.body.data.user,
          token: response.body.data.token,
        },
      });
    });
  });
});

describe('/users', () => {
  let testDBUser: Users;
  let testDBAdmin: Users;

  beforeAll(async () => {
    const encryptedPassword = await bcrypt.hash(
      acceptableUserData.password,
      config.hash.salt
    );

    const [dbUser, dbAdmin] = await Promise.all([
      prisma.users.create({
        data: {
          name: acceptableUserData.name,
          email: acceptableUserData.email,
          cpf: acceptableUserData.cpf,
          // password: '123123',
          password: encryptedPassword,
          role: 'DENTIST',
          company: {
            create: {},
          },
        },
      }),
      prisma.users.create({
        data: {
          name: 'Admin user',
          email: 'admin@email.com',
          password: encryptedPassword,
          role: 'ADMIN',
        },
      }),
    ]);

    testDBUser = dbUser;
    testDBAdmin = dbAdmin;
  });

  afterAll(async () => {
    await prisma.users.deleteMany({});
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    myAppInstance = await server.init();

    const [userPromise, adminPromise] = await Promise.all([
      request(myAppInstance).post('/session').send({
        email: testDBUser.email,
        password: acceptableUserData.password,
      }),

      request(myAppInstance).post('/session').send({
        email: testDBAdmin.email,
        password: acceptableUserData.password,
      }),
    ]);

    authenticatedAdmin = adminPromise.body.data;
    authenticatedUser = userPromise.body.data;
  });

  afterEach(() => {
    server.close();
  });

  describe('/users :: POST', () => {
    it('should return status 400, error message and invalid fields when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ name: '' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'All fields required.',
        fields: ['name'],
      });
    });

    it('should return status 400, error message and invalid fields when password is different than confirm_password', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, confirm_password: '123456' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Password/Confirm password must match.',
        fields: ['password', 'confirm_password'],
      });
    });

    it('should return status 400, error message and invalid fields when account_type is lower than 1 or higher than 2', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, account_type: 5 });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid account type.',
        fields: ['account_type'],
      });
    });

    it('should return status 400, error message and invalid fields when cpf is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, cpf: '123123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CPF/CNPJ.',
        fields: ['cpf'],
      });
    });

    it('should return status 400, error message and invalid fields when email is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, email: 'john.doe@' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid e-mail.',
        fields: ['email'],
      });
    });

    it('should return status 400, error message and invalid fields when CPF/CPNJ is already used', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ ...acceptableUserData, cpf: testDBUser.cpf });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'CPF/CNPJ already used.',
        fields: ['cpf'],
      });
    });

    it('should return status 400, error message and invalid fields when email is already used', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({
          ...acceptableUserData,
          // generated by https://geradornv.com.br/gerador-cpf/
          cpf: '185.339.850-02',
          email: testDBUser.email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'E-mail already used.',
        fields: ['email'],
      });
    });

    it("should return 201 and 'ok' mesasge when all input data is correct", async () => {
      const response = await request(myAppInstance).post('/users').send({
        name: 'Jane Doe',
        email: 'jane.doe@email.com',
        // generated by https://geradornv.com.br/gerador-cpf/
        cpf: '185.339.850-02',
        password: '123123',
        confirm_password: '123123',
        account_type: 1,
      });

      expect(response.statusCode).toEqual(201);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'uid',
          'name',
          'email',
          'birth',
          'active',
          'address',
          'company',
          'cpf',
          'cro',
          'phone',
          'cellphone',
          'post',
        ].sort()
      );
      expect(response.body.message).toEqual('ok');
    });
  });

  describe('/users :: PUT', () => {
    it('should return status 400 and error message when user_password and confirm_user_password does not match', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({ user_password: '123123', user_confirm_password: '123456' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Password/Confirm password must match.',
        fields: ['user_password', 'user_confirm_password'],
      });
    });

    it('should return status 400 and error message when user_email and user_confirm_email does not match', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_email: 'new-email@email.com',
          user_confirm_email: 'different-email@email.com',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'E-mail/Confirm e-mail must match.',
        fields: ['user_email', 'user_confirm_email'],
      });
    });

    it('should return status 400 and error message when user_email is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_email: 'new-email@email',
          user_confirm_email: 'new-email@email',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid user e-mail.',
        fields: ['user_email'],
      });
    });

    it('should return status 400 and error message when user_email is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_email: alreadyRegisteredUser.email,
          user_confirm_email: alreadyRegisteredUser.email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'User e-mail already used.',
        fields: ['user_email'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return status 400 and error message when user_cpf is invalid', async () => {
      const {
        body: {
          data: { token },
        },
      } = await request(myAppInstance)
        .post('/session')
        .send({ email: testDBAdmin.email, password: '123123' });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${token}`)
        .send({
          user_cpf: 'invalid-cpf',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CPF.',
        fields: ['user_cpf'],
      });
    });

    it('should return status 400 and error message when company_primary_email is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_primary_email: 'invalid-email@email',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid primary e-mail.',
        fields: ['company_primary_email'],
      });
    });

    it('should return status 400 and error message when company_primary_email is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const alreadyRegisteredCompanyData = {
        primary_email: 'already-used@email.com',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
          company: {
            create: {
              primary_email: alreadyRegisteredCompanyData.primary_email,
            },
          },
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_primary_email: alreadyRegisteredCompanyData.primary_email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Primary e-mail already used.',
        fields: ['company_primary_email'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return status 400 and error message when company_secondary_email is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_secondary_email: 'invalid-email@email',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid secondary e-mail.',
        fields: ['company_secondary_email'],
      });
    });

    it('should return status 400 and error message when company_secondary_email is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const alreadyRegisteredCompanyData = {
        secondary_email: 'already-used@email.com',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
          company: {
            create: {
              secondary_email: alreadyRegisteredCompanyData.secondary_email,
            },
          },
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_secondary_email: alreadyRegisteredCompanyData.secondary_email,
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Secondary e-mail already used.',
        fields: ['company_secondary_email'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return status 400 and error message when user_cnpj is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_cnpj: 'invalid-cnpj',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CNPJ.',
        fields: ['company_cnpj'],
      });
    });

    it('should return status 400 and error message when company_cnpj is already used', async () => {
      const alreadyRegisteredUserData = {
        name: 'Already Registered User',
        email: 'already-registered@email.com',
        password: '123123',
      };

      const alreadyRegisteredCompanyData = {
        // generated by https://geradornv.com.br/gerador-cpf/
        cnpj: '93110632000199',
      };

      const encriptedPassword = await bcrypt.hash(
        alreadyRegisteredUserData.password,
        config.hash.salt
      );

      const alreadyRegisteredUser = await prisma.users.create({
        data: {
          ...alreadyRegisteredUserData,
          password: encriptedPassword,
          company: {
            create: {
              cnpj: alreadyRegisteredCompanyData.cnpj,
            },
          },
        },
        include: {
          company: true,
        },
      });

      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_cnpj: '93110632000199',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'CNPJ already used.',
        fields: ['company_cnpj'],
      });

      await prisma.users.delete({
        where: {
          uid: alreadyRegisteredUser.uid,
        },
      });
    });

    it('should return status 400 and error message when company_phone is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_phone: 'invalid-phone',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid Phone.',
        fields: ['company_phone'],
      });
    });

    it('should return status 400 and error message when company_cellphone is invalid', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          company_cellphone: 'invalid-cellphone',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid Cellphone.',
        fields: ['company_cellphone'],
      });
    });

    it('should return 200 and ok message when all input data is correct', async () => {
      const response = await request(myAppInstance)
        .put(`/users/${authenticatedUser.user.id}`)
        .set('Authorization', `Bearer ${authenticatedUser.token}`)
        .send({
          user_name: 'Test User',
          user_birth: '1992-03-06T00:00:00.000Z',
          user_address: 'John Doe Avenue 890',
          user_email: 'john.doe.test@email.com',
          user_confirm_email: 'john.doe.test@email.com',
          user_post: 'Dentist',
          user_password: '123123',
          user_confirm_password: '123123',
          company_name: 'John Doe Company',
          company_primary_email: 'john.doe.test.primary@john-doe-company.com',
          company_secondary_email:
            'john.doe.test.secondary@john-doe-company.com',
          company_cellphone: '11999112211',
          company_phone: '1131313232',
          company_cnpj: '58349746000195',
          company_webiste: 'https://john-doe-company.com',
          company_address: 'John Doe Company Avenue, 1337',
        });

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'uid',
          'name',
          'email',
          'birth',
          'address',
          'company',
          'cpf',
          'cro',
          'phone',
          'cellphone',
          'post',
        ].sort()
      );
      expect(Object.keys(response.body.data.company).sort()).toEqual(
        [
          'address',
          'primary_email',
          'secondary_email',
          'cellphone',
          'cnpj',
          'name',
          'phone',
          'website',
        ].sort()
      );
      expect(response.body.message).toEqual('ok');
    });
  });

  describe('/users :: DELETE', () => {
    it('should return status 200 and ok message when correct id is sent', async () => {
      const deletedUserData = {
        name: 'Johnny Doe',
        email: 'johnny.doe@email.com',
        // generated by https://www.4devs.com.br/gerador_de_cpf
        cpf: '22210958040',
        password: '123123',
      };

      const encriptedPassword = await bcrypt.hash(
        deletedUserData.password,
        config.hash.salt
      );

      const deletedUser = await prisma.users.create({
        data: {
          ...deletedUserData,
          password: encriptedPassword,
          company: {
            create: {},
          },
        },
      });

      const response = await request(myAppInstance)
        .delete(`/users/${deletedUser.uid}`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'ok',
      });

      await prisma.users.delete({
        where: {
          uid: deletedUser.uid,
        },
      });
    });
  });

  describe('/users :: GET', () => {
    it('should return status 200 and a list of users', async () => {
      const response = await request(myAppInstance)
        .get(`/users`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toBe('ok');
      expect(Array.isArray(response.body.data)).toBe(true);
    });
  });

  describe('/users/:id :: GET', () => {
    it('should return status 403 and error message when invalid id is sent', async () => {
      const response = await request(myAppInstance)
        .get(`/users/invalid-id`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(403);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid id.',
      });
    });

    it('should return status 400 and error message when user is not found', async () => {
      const response = await request(myAppInstance)
        .get(`/users/84fd6184-7ca2-4a90-be6b-a0341f1b3b3c`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'User not found',
      });
    });

    it('should return status 200 and user data when correct id is sent', async () => {
      const response = await request(myAppInstance)
        .get(`/users/${testDBUser.uid}`)
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toBe('ok');
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'uid',
          'name',
          'email',
          'active',
          'address',
          'company',
          'cpf',
          'cro',
          'phone',
          'cellphone',
          'birth',
          'post',
        ].sort()
      );
      expect(Object.keys(response.body.data.company).sort()).toEqual(
        [
          'uid',
          'primary_email',
          'secondary_email',
          'name',
          'cnpj',
          'cellphone',
          'phone',
          'address',
          'website',
          'active',
        ].sort()
      );
    });
  });
});

// PATIENTS
describe('/patients', async () => {
  let testDBDentist: Users;

  beforeAll(async () => {
    const encryptedPassword = await bcrypt.hash(
      acceptableUserData.password,
      config.hash.salt
    );

    const [dbDentist] = await Promise.all([
      prisma.users.create({
        data: {
          name: acceptableDentistData.name,
          email: acceptableDentistData.email,
          cpf: acceptableDentistData.cpf,
          // password: '123123',
          password: encryptedPassword,
          role: 'DENTIST',
          company: {
            create: {},
          },
        },
      }),
      prisma.users.create({
        data: {
          name: 'Admin user',
          email: 'admin@email.com',
          password: encryptedPassword,
          role: 'ADMIN',
        },
      }),
    ]);

    testDBDentist = dbDentist;
  });

  afterAll(async () => {
    await prisma.users.deleteMany({});
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    myAppInstance = await server.init();

    const [dentistPromise, adminPromise] = await Promise.all([
      request(myAppInstance).post('/session').send({
        email: acceptableDentistData.email,
        password: acceptableDentistData.password,
      }),
      request(myAppInstance).post('/session').send({
        email: 'admin@email.com',
        password: '123123',
      }),
    ]);

    authenticatedDentist = dentistPromise.body.data;
    authenticatedAdmin = adminPromise.body.data;
  });

  afterEach(() => {
    server.close();
  });

  describe('/patients :: POST', () => {
    it('should return status 400, error message and invalid fields when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/users')
        .send({ patient_name: '' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'All fields required.',
        fields: ['patient_name'],
      });
    });

    it('should return status 400, error message and invalid fields when cpf is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData, patient_cpf: '123123123' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid CPF.',
        fields: ['patient_cpf'],
      });
    });

    it('should return status 400, error message and invalid fields when patient cpf is already used', async () => {
      const registeredPatient = await prisma.users.update({
        where: {
          uid: testDBDentist.uid,
        },
        data: {
          patients: {
            connectOrCreate: {
              create: {
                cpf: acceptablePatientData.patient_cpf,
                name: acceptablePatientData.patient_name,
                role: 'PATIENT',
                address: acceptablePatientData.patient_address,
                birth: acceptablePatientData.patient_birth,
                cellphone: acceptablePatientData.patient_cellphone,
                email: acceptablePatientData.patient_email,
                sex: false,
                zip_code: acceptablePatientData.patient_zip,
              },
              where: {
                cpf: acceptablePatientData.patient_cpf,
              },
            },
          },
        },
        select: {
          patients: {
            where: {
              cpf: acceptablePatientData.patient_cpf,
            },
          },
        },
      });

      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'You already have a patient with this CPF',
        fields: ['patient_cpf'],
      });

      await prisma.patients.delete({
        where: {
          uid: registeredPatient.patients[0].uid,
        },
      });
    });

    it('should return status 400, error message and invalid fields when email is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData, patient_email: 'invalid-email' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid e-mail.',
        fields: ['patient_email'],
      });
    });

    it('should return status 400, error message and invalid fields when sex is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ ...acceptablePatientData, patient_sex: 'invalid-sex' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid sex.',
        fields: ['patient_sex'],
      });
    });

    it('should return status 400, error message and invalid fields when date is invalid or is after today', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
          patient_birth: new Date('01/01/2099').toISOString(),
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid birth date.',
        fields: ['patient_birth'],
      });
    });

    it('should return status 400, error message and invalid fields when cellphone is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
          patient_cellphone: 'invalid-cellphone',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid cellphone/phone.',
        fields: ['patient_cellphone'],
      });
    });

    it('should return status 400, error message and invalid fields when zipcode is invalid', async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
          patient_zip: 'invalid-zip',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid zipcode.',
        fields: ['patient_zip'],
      });
    });

    it("should return 201 and 'ok' message when all input data is correct", async () => {
      const response = await request(myAppInstance)
        .post('/patients')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptablePatientData,
        });

      expect(response.statusCode).toEqual(201);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(Object.keys(response.body.data).sort()).toEqual(
        [
          'name',
          'email',
          'address',
          'birth',
          'cellphone',
          'cpf',
          'sex',
          'zip_code',
          'uid',
        ].sort()
      );
      expect(response.body.message).toEqual('ok');

      await prisma.patients.delete({
        where: {
          uid: response.body.data.uid,
        },
      });
    });
  });

  describe('/patients :: GET', () => {
    it('should return status 200 and patient list with its respective owner', async () => {
      const response = await request(myAppInstance)
        .get('/patients')
        .set('Authorization', `Bearer ${authenticatedAdmin.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toEqual('ok');
      expect(Array.isArray(response.body.data)).toBeTruthy();
    });
  });

  describe('/patients/:id :: GET', () => {
    it('should return status 200, uid, name and a list of its patients', async () => {
      const patient = await prisma.users.update({
        where: {
          uid: testDBDentist.uid,
        },
        data: {
          patients: {
            create: {
              cpf: acceptablePatientData.patient_cpf,
              name: acceptablePatientData.patient_name,
              address: acceptablePatientData.patient_address,
              birth: new Date(
                acceptablePatientData.patient_birth
              ).toISOString(),
              cellphone: acceptablePatientData.patient_cellphone,
              email: acceptablePatientData.patient_email,
              zip_code: acceptablePatientData.patient_zip,
              sex: acceptablePatientData.patient_sex === 'M',
            },
          },
        },
        select: {
          patients: true,
        },
      });

      const response = await request(myAppInstance)
        .get(`/patients/${testDBDentist.uid}`)
        .set('Authorization', `Bearer ${authenticatedDentist.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toEqual('ok');
      expect(Object.keys(response.body.data).sort()).toEqual(
        ['name', 'uid', 'patients'].sort()
      );
      expect(response.body.data.patients[0].name).toEqual(
        acceptablePatientData.patient_name
      );
      expect(response.body.data.patients[0].email).toEqual(
        acceptablePatientData.patient_email
      );
      expect(response.body.data.patients[0].address).toEqual(
        acceptablePatientData.patient_address
      );
      expect(response.body.data.patients[0].birth.split('T')[0]).toEqual(
        acceptablePatientData.patient_birth.split('T')[0]
      );
      expect(response.body.data.patients[0].cellphone).toEqual(
        acceptablePatientData.patient_cellphone
      );
      expect(response.body.data.patients[0].cpf).toEqual(
        acceptablePatientData.patient_cpf
      );
      expect(response.body.data.patients[0].sex).toEqual(
        acceptablePatientData.patient_sex === 'M'
      );
      expect(response.body.data.patients[0].zip_code).toEqual(
        acceptablePatientData.patient_zip
      );

      await prisma.patients.delete({
        where: {
          uid: patient.patients[0].uid,
        },
      });
    });
  });

  describe('/patients/:patient_id :: DELETE', () => {
    it('should return status 200', async () => {
      const user = await prisma.users.update({
        where: {
          uid: testDBDentist.uid,
        },
        data: {
          patients: {
            create: {
              cpf: acceptablePatientData.patient_cpf,
              name: acceptablePatientData.patient_name,
              address: acceptablePatientData.patient_address,
              birth: acceptablePatientData.patient_birth,
              cellphone: acceptablePatientData.patient_cellphone,
              email: acceptablePatientData.patient_email,
              role: 'PATIENT',
              sex: acceptablePatientData.patient_sex === 'M',
              zip_code: acceptablePatientData.patient_zip,
            },
          },
        },
        select: {
          patients: true,
        },
      });

      const response = await request(myAppInstance)
        .delete(`/patients/${user.patients[0].uid}`)
        .set('Authorization', `Bearer ${authenticatedDentist.token}`);

      expect(response.statusCode).toEqual(200);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toBe('ok');

      await prisma.patients.delete({
        where: {
          uid: user.patients[0].uid,
        },
      });
    });
  });
});

// PROSTHETICS
describe('/prosthetics', () => {
  // let testDBDentist: Users;
  // let testDBLab: Users;

  // PROSTHETICS ORDERS
  describe('/prosthetics/orders :: POST', async () => {
    let acceptableDentistProstheticOrderData: any;
    let encriptedPassword: string;

    beforeAll(async () => {
      encriptedPassword = await bcrypt.hash(
        acceptableUserData.password,
        config.hash.salt
      );

      const [testDBDentist, testDBLab] = await Promise.all([
        prisma.users.create({
          data: {
            email: acceptableDentistData.email,
            name: acceptableDentistData.name,
            password: encriptedPassword,
            role: 'DENTIST',
            company: {
              create: {},
            },
            patients: {
              create: {
                cpf: acceptablePatientData.patient_cpf,
                name: acceptablePatientData.patient_name,
              },
            },
          },
          include: {
            company: true,
            patients: true,
          },
        }),
        prisma.users.create({
          data: {
            email: acceptableLabData.email,
            name: acceptableLabData.name,
            password: encriptedPassword,
            role: 'LAB',
            company: {
              create: {},
            },
          },
          include: {
            company: true,
          },
        }),
        prisma.users.create({
          data: {
            name: 'Admin user',
            email: 'admin@email.com',
            password: encriptedPassword,
            role: 'ADMIN',
          },
        }),
      ]);

      const [dentistAuthPromise, labAuthPromise, adminAuthPromise] =
        await Promise.all([
          request(myAppInstance).post('/session').send({
            email: testDBDentist.email,
            password: '123123',
          }),
          request(myAppInstance).post('/session').send({
            email: testDBLab.email,
            password: '123123',
          }),
          request(myAppInstance).post('/session').send({
            email: 'admin@email.com',
            password: '123123',
          }),
        ]);

      authenticatedDentist = dentistAuthPromise.body.data;
      authenticatedLab = labAuthPromise.body.data;
      authenticatedAdmin = adminAuthPromise.body.data;

      acceptableDentistProstheticOrderData = {
        prosthetic_order_patient_uid: testDBDentist.patients[0].uid,
        prosthetic_order_lab_uid: testDBLab.company?.uid,
        prosthetic_order_service_id: 1,
        prosthetic_order_options_id: 1,
        prosthetic_order_color_id: 1,
        prosthetic_order_deadline: addDays(new Date(), 7),
        prosthetic_order_teeth_elements: [11],
      };
    });

    afterAll(async () => {
      await prisma.prostheticOrders.deleteMany({});
      await prisma.patients.deleteMany({});
      await prisma.companies.deleteMany({});
      await prisma.users.deleteMany({});
      await prisma.$disconnect();
    });

    beforeEach(async () => {
      myAppInstance = await server.init();
    });

    afterEach(async () => {
      server.close();
    });

    // DENTIST VALIDATION
    it('should return status 400, error message and invalid fields when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({ prosthetic_order_lab_uid: '' });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Fields required.',
        fields: ['prosthetic_order_lab_uid'],
      });
    });

    it('should return status 400, error message and invalid field when patient uid is not valid', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_patient_uid: 'invalid-uid',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid patient id.',
        fields: ['prosthetic_order_patient_uid'],
      });
    });

    it('should return status 400, error message and invalid field when lab uid is not valid', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_lab_uid: 'invalid-uid',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid patient/lab id.',
        fields: ['prosthetic_order_lab_uid'],
      });
    });

    it('should return status 400, error message and invalid field when patient uid is valid but does not exist', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_patient_uid: 'ee17cb4a-9599-416d-8a11-916fbbb1b960',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Patient not found',
        fields: ['prosthetic_order_patient_uid'],
      });
    });

    it('should return status 400, error message and invalid field when lab uid is valid but does not exist', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_lab_uid: 'ee17cb4a-9599-416d-8a11-916fbbb1b960',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Lab not found',
        fields: ['prosthetic_order_lab_uid'],
      });
    });

    // LAB VALIDATION
    it('should return status 400, error message and invalid fields when one or more required fields are not sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedLab.token}`)
        .send({
          prosthetic_order_patient_name: '',
          prosthetic_order_dentist_name: '',
          prosthetic_order_deadline: '',
          prosthetic_order_service_id: '',
          prosthetic_order_teeth_elements: '',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Fields required.',
        fields: [
          'prosthetic_order_patient_name',
          'prosthetic_order_dentist_name',
          'prosthetic_order_deadline',
          'prosthetic_order_service_id',
          'prosthetic_order_teeth_elements',
        ],
      });
    });

    // GENERIC VALIDATION
    it('should return status 400, error message and invalid fields when invalid date is sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_deadline: 'invalid-deadline',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid deadline.',
        fields: ['prosthetic_order_deadline'],
      });
    });

    it('should return status 400, error message and invalid fields when past date is sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_deadline: new Date('01/01/2000'),
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid deadline.',
        fields: ['prosthetic_order_deadline'],
      });
    });

    it('should return status 400, error message and invalid fields when invalid service id is sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_service_id: 'invalid-service-id',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid service.',
        fields: ['prosthetic_order_service_id'],
      });
    });

    // TEST ONLY AVAILABLE WHEN SERVICE ID IS FROM A SERVICE THAT REQUIRES TOOTH ELEMENTS (i.e id = 1)
    it('should return status 400, error message and invalid fields when an array with invalid length (length <= 0) is sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_teeth_elements: [],
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Elements required.',
        fields: ['prosthetic_order_teeth_elements'],
      });
    });

    it('should return status 400, error message and invalid fields when an invalid value is sent instead an array', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_teeth_elements: 'invalid-value-instead-array',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid elements.',
        fields: ['prosthetic_order_teeth_elements'],
      });
    });

    it('should return status 400, error message and invalid fields when an invalid value is sent in the array', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_teeth_elements: [11, 'invalid', 'value'],
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid elements.',
        fields: ['prosthetic_order_teeth_elements'],
      });
    });

    // THIS TEST IS ONLY AVAILABLE WHEN A SERVICE HAVE OPTIONS
    it('should return status 400, error message and invalid fields when an invalid service option id is sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_options_id: 'invalid-option-id',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid options.',
        fields: ['prosthetic_order_options_id'],
      });
    });

    // THIS TEST IS ONLY AVAILABLE WHEN A SERVICE REQUIRES COLOR
    it('should return status 400, error message and invalid fields when an invalid service option id is sent', async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
          prosthetic_order_color_id: 'invalid-color-id',
        });

      expect(response.statusCode).toEqual(400);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body).toEqual({
        message: 'Invalid color.',
        fields: ['prosthetic_order_color_id'],
      });
    });

    it("should return 201 and 'ok' message when all input data is correct", async () => {
      const response = await request(myAppInstance)
        .post('/prosthetics/orders')
        .set('Authorization', `Bearer ${authenticatedDentist.token}`)
        .send({
          ...acceptableDentistProstheticOrderData,
        });

      expect(response.statusCode).toEqual(201);
      expect(response.headers['content-type']).toMatch(/json/);
      expect(response.body.message).toEqual('ok');
    });

    // THE FOLLOWING SEQUENCE TESTS SOME SERVICES OPTIONS AND ITS RESPECTIVES FINAL PRICES
    it('should match expected total results with database total column', async () => {
      await prisma.prostheticOrders.deleteMany({});

      const expected_0 = 76000;
      const expected_1 = 120000;
      const expected_2 = 126000;
      const expected_3 = 120000;
      const expected_4 = 7500;
      const expected_5 = 3000;
      const expected_6 = 12000;
      const expected_7 = 80000;
      const expected_8 = 6000;
      const expected_9 = 10000;

      const inputs = [
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 1,
            prosthetic_order_options_id: 1,
            prosthetic_order_color_id: 1,
            prosthetic_order_teeth_elements: [11, 12],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 1,
            prosthetic_order_options_id: 2,
            prosthetic_order_color_id: 1,
            prosthetic_order_teeth_elements: [11, 12, 21],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 2,
            prosthetic_order_options_id: 4,
            prosthetic_order_color_id: 1,
            prosthetic_order_teeth_elements: [11, 12, 21, 22, 24, 36, 37],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 3,
            prosthetic_order_options_id: 2,
            prosthetic_order_color_id: 1,
            prosthetic_order_teeth_elements: [11, 12, 21, 22, 36, 37],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 6,
            prosthetic_order_teeth_elements: [],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 7,
            prosthetic_order_teeth_elements: [],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 8,
            prosthetic_order_options_id: 2,
            prosthetic_order_color_id: 1,
            prosthetic_order_teeth_elements: [11, 12],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 9,
            prosthetic_order_teeth_elements: [
              11, 12, 13, 14, 15, 21, 22, 23, 24, 25,
            ],
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 11,
            prosthetic_order_options_id: 2,
          },
        },
        {
          data: {
            ...acceptableDentistProstheticOrderData,
            prosthetic_order_service_id: 11,
            prosthetic_order_options_id: 3,
          },
        },
      ];

      const promises = inputs.map((item) =>
        request(myAppInstance)
          .post('/prosthetics/orders')
          .set('Authorization', `Bearer ${authenticatedDentist.token}`)
          .send({
            ...item.data,
          })
      );

      await Promise.all(promises);

      const result = await prisma.prostheticOrders.findMany();

      result.forEach((item) => {
        if (
          item.service_name === 'Faceta' &&
          item.service_material === 'Dissilicato de lítio'
        ) {
          expect(item.total).toBe(expected_0);
        } else if (
          item.service_name === 'Faceta' &&
          item.service_material === 'Feldspática'
        ) {
          expect(item.total).toBe(expected_1);
        } else if (
          item.service_name === 'Coroa' &&
          item.service_material === 'Dissilicato de lítio'
        ) {
          expect(item.total).toBe(expected_2);
        } else if (
          item.service_name === 'Onlay/Inlay/Overlay' &&
          item.service_material === 'Resina fotopolimerizável'
        ) {
          expect(item.total).toBe(expected_3);
        } else if (item.service_name === 'Mockup + Guias de desgaste') {
          expect(item.total).toBe(expected_4);
        } else if (item.service_name === 'Modelo de estudo') {
          expect(item.total).toBe(expected_5);
        } else if (item.service_name === 'Provisório') {
          expect(item.total).toBe(expected_6);
        } else if (item.service_name === 'Aplicação de gengiva') {
          expect(item.total).toBe(expected_7);
        } else if (
          item.service_name === 'Placa de clareamento' &&
          item.service_material === 'Sup + Inf'
        ) {
          expect(item.total).toBe(expected_9);
        } else if (item.service_name === 'Placa de clareamento') {
          expect(item.total).toBe(expected_8);
        }
      });
    });
  });
});
